So the way that this currently works is that you place the videos you want to processes in the videos folder and  run the ScriptManager.py program and that should run through and attempt to process a video.
Important notes though are that the templates need to be changed as per setup, this should not be to difficult by implementing something such as a template select in the GUI (after it is implemented) after a video is split into its individual frames, but is important because the current templates are specific to our setup at Octorara. 
For this to work we also required a dark background to give the ball contrast against so that the program was able to easily distinguish the ball from the background. Without this the program would mark points in the background I did do some code to mitigate this but it probably isnt the best solution. What this looked like for our setup was the orbital shaker had a black piece of paper over it that was taped to the rubber layer, and the petri dish was also painted with a matte black spraypaint to give better contrast.
We also used an overhead light in our case to give give the program a distinguishing thing to look at; the light that was reflected from the direct center of the balls offered a perfect feature for the image matching to consistently find.
There also is no way for the program to find the framrate of the video that you are using I hardcoded in 240 fps in all the math because it was the only fps value that we recorded at.
I added as many notes as I could because I know my code is messy because I didnt know at the time of writing it anyone but me would be looking at it, there are many commented out lines for debugging and old code that is multiline commented out that is still there from prior iterations that is not longer used, also the same with functions that are no longer used.
The naming of the video files is also important at least for the current version, I used a system initially which was just the default name that the camera spit out and had a format of CXXXX.MP4 where the xs just where a counter starting at 0. This changed though as I found it necessary to implement some way for the program to know the type as we tried close to the end to analyze runs using a differnt type of bearing, so I switched to a format like this. LFLBXX.MP4 where the first two letters denote wether the test was high friction or low friction with LF or HF and then LB or SB for the next to letters indicating the bearing size, either large bearing or small bearing(this was used for the program to know which template to select from the folder). Then finally a two digit number indicating the number of bearings in the video. This is important because close to the end I attempted to implement a system where the code checks the number of bearings it detects in the first frame and checks it against the video title to ensure we have the right amount, this alhough broke already existing code that did this but without the title and for all frames post frame0, I never had time to fix it because we were so close to presenting and if I do fix it or dont I will ensure its commented on in the code.
The code outputs a lot of files in a weird structure that could be optimized as well, when a video is split it creates a folder in the FrameExport folder with the video title(including its file type) where each frame is exported to starting at 0-the number of frames. Then during analysis in the Data folder a folder is created with the same name as the video again and then a bunch of subfolders are created. In the main "./Data/videoname" folder there is a text file for each frame the program analyses in each of these text files is in order their x positions all lists down then contiuing down their y positions. The subfolders are created named relativex, relativey, COMData,and ClusterAngularVelocity. The relativex and relativey folders just contain each frames bearing positions relative to the frames COM. The COMData folder contains a textfile for each frame containing its center of mass position, and finally the ClusterAngularVelocity folder contains one text file with the clusters average angular velocity in it.

I think thats all the notes really that are important, hopefully I didnt make any horrible mistakes in either the math or the detection algorithms, and hopefully this code is at all helpful!